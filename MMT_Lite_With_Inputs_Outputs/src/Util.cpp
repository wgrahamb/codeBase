//----------------------------------------------------------------//
// File: Util.cpp
// 
// This class is used to fascilate the use of user-defined error
// statistics within the simulation and Monte-Carlo performance
// analysis.
//
// Developer:         Dennis Strickland
//----------------------------------------------------------------//

#include <iostream>
#include <sstream>
#include "math.h"
#include "System.h"
#include "Util.h"

MathUtil::MathUtil(System *sysp)
{
  
  //Local access
  sys = sysp;
  
  //Default Values
  mctl.restartFlag = true;
  //
  mctl.mu     =  0.0;
  mctl.xll    = -3.0;
  mctl.xuu    =  3.0;
  mctl.uclamp = -1;
}

//---------------------------------------------//

MathUtil::~MathUtil()
{

}

//---------------------------------------------//

double MathUtil::gaus(double xsigma, bool zero_for_nominal)
{
  //Returns Gaussian distribution from -xsigma to +xsigma standard deviation
  //with zero mean. The mean can be passed in as another argument while
  //commenting out the zero mean in the code.

  //GAUS RANDOMLY SELECTS A POINT ON THE PHI(Z) CURVE, WHERE PHI(Z)
  //IS THE NORMAL DISTRIBUTION FUNCTION WITH :
  //           MEAN = 0 AND VARIANCE = 1, AND
  //ITS CURVE IS GENERATED BY INTEGRATING FROM 0 TO 5 XSIGMA
  //THE DENSITY FUNCTION :
  //( 1/DSQRT(2PI) ) * ( E RAISED TO THE -1/2 T**2 POWER )
  //AFTER THIS, THE CORRESPONDING X-AXIS VALUE IS DESIGNATED AS
  //THE RETURNED MONTE CARLO VALUE IN rxnorm, WITH rxnorm=F(PHI(Z)).
  //THE MEAN AND VARIANCE CAN BE SCALED FOR NONZERO MEANS AND
  //NON-UNITY VARIANCES
  //
  //FZ ARRAY CONTAINS THE VALUES FOR THE POINTS ON THE POSITIVE
  //PORTION OF THE DISTRIBUTION FUNCTION CURVE, PHI(Z)
  //
  //Developer:  Dennis Strickland

  const int    ntp   = 126;
  const double dtt   = 0.01;
  const double dt1   = 0.04;
  const double sq2pi = 0.398942283;

  static int     npt = 0;
  static double fz[126];

  long iseed;
  int  icntx;
  double var,t2,t,f,fc,fp;
  double dt2,r_r,x1,rnnorm;
  double rxnorm,gaus_val;

  //Compute seed
  var   = unif(zero_for_nominal);
  iseed = long(mctl.seed);
  
  //Normal curve lower and upper bounds are functions of the mean
  //and standard deviation
  //
  //Must have acceptable bounds
  icntx = 0;
  if(mctl.xll >= mctl.xuu) {
    icntx    = icntx + 1;
    rxnorm   = 0.0;
    gaus_val = rxnorm;
    return gaus_val;
  }

  //Initialize time to store point, first phi(z) value, first cumulative
  //function value, independent variable, calculate function at t=0,
  //initialize number of points on curve to 1
  if(npt == 0) {
    t2    = dt1;
    fz[0] = 0.5;
    fc    = fz[0];
    t     = 0.0;
    fp    = sq2pi*exp(-0.05*t*t);
    dt2   = dtt*0.5;
    npt   = 0;

    //Use trapezoidal rule to approximate area under probability density
    //curve for every point in fz array
    //sum over 4 dt intervals before storing a point
    t  = t + dtt;
    f  = sq2pi*exp(-0.5*t*t);
    fc = fc + dt2*(f + fp);
    fp = f;
    label_10:
    if(fabs(t-t2) > 0.0001) {
      t  = t + dtt;
      f  = sq2pi*exp(-0.5*t*t);
      fc = fc + dt2*(f + fp);
      fp = f;
      goto label_10;
    }

    //Update # of points, store current value of trapezoid approximation
    //in fz, and update time to store next point
    npt     = npt + 1;
    fz[npt] = fc;
    t2      = t2 + dt1;
    label_11:
    if(npt < ntp-1) {
      //Sum over 4 dt intervals before storing a point
      t  = t + dtt;
      f  = sq2pi*exp(-0.5*t*t);
      fc = fc + dt2*(f + fp);
      fp = f;
      label_12:
      if(fabs(t-t2) > 0.0001) {
        t  = t + dtt;
        f  = sq2pi*exp(-0.5*t*t);
        fc = fc + dt2*(f + fp);
        fp = f;
        goto label_12;
      } 

      //Update # of points, store current value of trapezoid approximation
      //in fz, and update time to store next point
      npt       = npt + 1;
      fz[npt] = fc;
      t2        = t2 + dt1;
      goto label_11;
    } //npt < ntp
  } //npt = 0

  //Select random point on fz curve by generating a uniformly distributed
  //random variavle between 0.5 and 1.0.  Then locate fz element with that
  //value, interpolate, if necessary and find corresponding x-axis value
  //which is "rxnorm".
  //Generate a uniformly distributed random variable, R between 0.5 and 1.
  //The corresponding fz element is located and its related x-axis value
  //becomes the returned "rxnorm" (normally distributed).

  rnnorm = rnfst(&iseed);
  r_r    = rnnorm;

  if(rnnorm < 0.5) { r_r = 1.0 - rnnorm; }
  label_13:
  if(r_r > fz[npt]) {
    rnnorm = rnfst(&iseed);
    r_r    = rnnorm;
    if(rnnorm < 0.5) { r_r = 1.0 - rnnorm; }
    goto label_13;
  }

  //Select an fz element
  for(int i=0; i<npt; i++) {
     if(r_r <= fz[i]) {
       if(i == 0) {
         rxnorm = 0.0;
       } else {
         //linear interpolation is necessary
         x1     = dt1*(i-1);
         rxnorm = x1 + (r_r - fz[i-1])*dt1/(fz[i] - fz[i-1]);
       }
       goto label_5;
     }
  }
  label_5:

  //Location in negative portion of curve
  if(rnnorm < 0.5) { rxnorm = -rxnorm; }

  //Clamp Gaussian distribution to x11 and xuu limits
  label_15:
  if(mctl.uclamp == 1) {
    
    if( (rxnorm > mctl.xuu) || (rxnorm < mctl.xll) ) {

       //Generate a uniformly distributed random variable, R between 0.5 and 1.
       //The corresponding fz element is located and its related x-axis value
       //becomes the returned "rxnorm" (normally distributed).

       rnnorm = rnfst(&iseed);
       r_r    = rnnorm;

       if(rnnorm < 0.5) { r_r = 1.0 - rnnorm; }
       label_16:
       if(r_r > fz[npt]) {
         rnnorm = rnfst(&iseed);
         r_r    = rnnorm;
         if(rnnorm < 0.5) { r_r = 1.0 - rnnorm; }
         goto label_16;
       }

       //Select an fz element
       for(int i=0; i<npt; i++) {
         if(r_r <= fz[i]) {
           if(i == 0) {
             rxnorm = 0.0;
           } else {
             //linear interpolation is necessary
             x1     = dt1*(i-1);
             rxnorm = x1 + (r_r - fz[i-1])*dt1/(fz[i] - fz[i-1]);
           }
           goto label_55;
         }
      }
      label_55:

      //location in negative portion of curve
      if(rnnorm < 0.5) { rxnorm = -rxnorm; }
      goto label_15;

    } //xuu/xll

  } //uclamp
 
  //Scale for non-zero means and non-unity variances
  rxnorm = xsigma*rxnorm + mctl.mu;

  //Output return value
  if(zero_for_nominal) {  //Nominal Run
    gaus_val = 0.0;
  } else {
    gaus_val = rxnorm;
  }

  return gaus_val;

}

//---------------------------------------------//

double MathUtil::rnfst(long *ix)
{
  //Used by gaus() to modify the seed
  //
  //Developer:  Dennis Strickland
  
  int iy;
  double rnfst_val;

  iy = *ix*65539;

  if(iy < 0)  {
    iy = iy + 2147483647 + 1;
  } 
  rnfst_val = iy;
  rnfst_val = rnfst_val/2147483647.0;
  *ix = iy;

  return rnfst_val;

}

//---------------------------------------------//

double MathUtil::unif(bool zero_for_nominal)
{
  //Returns uniform distribution from -1.0 to 1.0.
  //
  //Developer:  Dennis Strickland

  //constants used in uniform draw calculation
  const int im1 = 2147483563;
  const int ia1 = 40014;
  const int iq1 = 53668;
  const int ir1 = 12211;
  const int iq2 = 52774;
  const int ia2 = 40692;
  const int ir2 = 3791;
  const int im2 = 2147483399;
  const int imm1 = im1-1;
  const int ntab = 32;
  const int ndiv = 1+imm1/ntab;
  const double eps  = 1.2e-7;
  const double rnmx = 1.0-eps;
  const double am   = 1.0/im1;

  int j,k;
  double unif_val;

  static int idum2,iy,iv[32];

  if(mctl.restartFlag) {
    idum2 = mctl.seed;
    iy    = 0;
    for(int i=0; i<ntab; i++) {
       iv[i] = 0;
    }
    mctl.restartFlag = false;
  }
  //
  if(mctl.seed <= 0) {
    mctl.seed = fmax(long(-mctl.seed),1);
    idum2    = long(mctl.seed);
    for(int j=ntab+7; j>=0; j--) {
       k = long(mctl.seed)/iq1;
       mctl.seed = ia1*(long(mctl.seed) - k*iq1) - k*ir1;
       if(long(mctl.seed) < 0) { mctl.seed = long(mctl.seed) + im1; }
       if(j < ntab) { iv[j] = long(mctl.seed); }
    }
    iy = iv[0];
  }
  //
  k = long(mctl.seed)/iq1;
  mctl.seed = ia1*(long(mctl.seed) - k*iq1) - k*ir1;
  if(int(mctl.seed) < 0) { mctl.seed = long(mctl.seed) + im1; }
  k = idum2/iq2;
  idum2 = ia2*(idum2 - k*iq2) - k*ir2;
  if(idum2 < 0) { idum2 = idum2 + im2; }
  j = 1 + iy/ndiv;
  iy = iv[j-1] - idum2;
  iv[j-1] = long(mctl.seed);
  if(iy < 1) { iy = iy + imm1; }
  //
  unif_val = fmin(am*iy,rnmx);

  double return_value = 2.0*unif_val-1.0;
  if (zero_for_nominal) {  //Nominal Run
      return_value = 0.0;
  }

  return return_value; 
}

//-------------------------------------------------------//

void MathUtil::setInitSeed(int runNum)
{
  //Set seed from seeds.dat file
  mctl.seed = vecSeeds.at(runNum);

  //Set restartFlag to start new run.
  mctl.restartFlag = true;

}

//-------------------------------------------------------//

void MathUtil::readSeeds()
{
   //FILE *fpSeed;
   ifstream inFile;
   string   dataLine, wd1, wd2;
   int runNum;
   long ceed;

   inFile.open("input/seeds.dat");

   //Read Seeds
   vecSeeds.clear();
   getline(inFile, dataLine);
   getline(inFile, dataLine);
   while(!inFile.eof()) {

     //get line and parse it
     inFile >> wd1 >> wd2;

     //Store Seeds
     vecSeeds.push_back(atol(wd2.c_str()));

   }

   inFile.close();

}

//-------------------------------------------------------//

void MathUtil::genSeeds(int numSeeds)
{
   ofstream outFile;
   stringstream sstm;
   long iseed;

   outFile.open("input/seeds.dat", ios_base::out);

   //store initial seed
   iseed = sys->iseed;

   sstm << "#This file contains initial seeds for the runs designated." << endl
        << "#Input (numRuns  initialSeed): " << numSeeds << "  " << iseed << endl;

   for(int i=0; i<numSeeds+1; i++) {
      double var = rnfst(&sys->iseed)*1.0e8;   
      long ceed = -(long)fabs(var);
      if(i == 0) { ceed = 0; }

      sstm << i << "  " << ceed << endl;
   }

   outFile << sstm.str();
   outFile.close();

   //Output message to screen
   cout << endl << "-------------------------------------------" << endl;
   cout << numSeeds << " seeds were generated using initial seed " << iseed << endl;
   cout << "See \"seeds.dat\" in the input directory." << endl;
   cout << "-------------------------------------------" << endl << endl;

}

//-------------------------------------------------------//

double MathUtil::unif_r(string descr, bool disable,
                        bool report_zero)
{
   //This routine provides a means to identify and report 
   //the uniform draw.  This is useful for post-run analysis.
   //
   //Developer:  Dennis Strickland

   double unif_val;


   unif_val = unif(true);
   if (disable) {
     unif_val = 0.0;
   }

  //  if (report_zero) {
  //    ds->mcarlo.uvalue.push_back(0.0);
  //  } else {
  //    ds->mcarlo.uvalue.push_back(unif_val);
  //  }
  //  //
  //  ds->mcarlo.uname.push_back(descr);

   return unif_val;
}

//-------------------------------------------------------//

double MathUtil::gaus_r(double xsigma, string descr, bool disable,
                        bool report_zero)
{
   //This routine provides a means to identify and report 
   //the gaussian draw.  This is useful for post-run analysis.
   //
   //Developer:  Dennis Strickland
   
   double gaus_val;

   gaus_val = gaus(xsigma, true);
   if (disable) {
     gaus_val = 0.0;
   }

  //  if(xsigma == 0.0) {
  //    ds->mcarlo.gvalue.push_back(0.0);
  //  } else {
  //    if (report_zero) {
  //      ds->mcarlo.gvalue.push_back(0.0);
  //    } else {
  //      ds->mcarlo.gvalue.push_back(gaus_val/xsigma);
  //    }
  //  }
  //  //
  //  ds->mcarlo.gname.push_back(descr);

   return gaus_val;
}

//-------------------------------------------------------//

double MathUtil::signum( double x) {
  double y;
  if( x < 0.0) {
    y = -1.0;
  } else if ( x > 0.0) {
    y = 1.0;
  } else {
    y = 0.0;
  }
  return y;
}

//-------------------------------------------------------//

double MathUtil::limit( double x, double xmin, double xmax) {
  double y;
  if( x < xmin) {
    y = xmin;
  } else if( x > xmax) {
    y = xmax; 
  } else {
    y = x;
  }
  return y;
}

//-------------------------------------------------------//

double MathUtil::rss( double x, double y) {
  return sqrt( x * x + y * y);
}

//-------------------------------------------------------//

double MathUtil::to_db( double x) {
  return 10.0 * log10( x);
}

//-------------------------------------------------------//

double MathUtil::from_db( double x) {
  return pow( 10, x / 10.0);
}

//-------------------------------------------------------//

double MathUtil::normal( double sig) {
  double sample = 0.0;
  for( int i = 0; i < 12; i++) {
    sample += ( double)rand() / RAND_MAX;
  }
  double x = sig * ( sample - 6.0);
  return x;
}

//-------------------------------------------------------//

double MathUtil::atan2_0( double y, double x) {
  if( x == 0.0 && y == 0.0) {
    return 0.0;
  } else {
    return atan2( y, x);
  } 
}

//-------------------------------------------------------//

void MathUtil::pop_unif_r()
{
    // ds->mcarlo.uvalue.pop_back();
    // ds->mcarlo.uname.pop_back();
}

//-------------------------------------------------------//

void MathUtil::pop_gaus_r()
{
    // ds->mcarlo.gvalue.pop_back();
    // ds->mcarlo.gname.pop_back();
}

//-----------------------------------------------------//

