//------------------------------------------------------//
// File: Motion.cpp
//
// This class implements the equations of motion for
// an unsymmetric missile and solves for the missile's
// translational/rotational dynamics.
//
//
// Developer: Dennis Strickland
//------------------------------------------------------//

#include <memory>
#include "Motion.h"
#include "reFactoredGeometry.h"

//Complex Aero Constructor
Motion::Motion(
	string infile,
	double timeOfFlightStep,
	double phi0,
	double theta0,
	double psi0,
	double lat0,
	double lon0,
	double alt0,
	double targetAzimuth,
	int integrationMethod
)
{

	cout << "MOTION CONSTRUCTED" << endl;

	//Input
	Filer *ff = new Filer( "./input/"+infile);
	ff->setLine0( "Motion");
	spinFlag = ff->getInt("spin_Flag");
	pScale = ff->getDouble("pScale");
	deg_tol = ff->getDouble( "deg_tol");
	delete ff;

	// Pointer.
	re_factored_geo = make_shared<reFactoredGeometry>();

	//Zero Values
	omegaB_d = Vec( 0.0, 0.0, 0.0);
	quat_d   = Quat( 0.0, 0.0, 0.0, 0.0);
	vb       = Vec( 0.0, 0.0, 0.0);

	re_factored_geo->init(
		phi0,
		theta0,
		psi0,
		lat0,
		lon0,
		alt0,
		targetAzimuth
	);

	missileTimeOfFlightStep = timeOfFlightStep;

	cout.precision(12);

	//Initialize
	force    = Vec( 0.0, 0.0, 0.0);
	moment   = Vec( 0.0, 0.0, 0.0);
	omegaB   = Vec( 0.0, 0.0, 0.0);
	omegaB_d = Vec( 0.0, 0.0, 0.0);
	tipoff   = Vec( 0.0, 0.0, 0.0);
	sf_b     = Vec( 0.0, 0.0, 0.0);
	ipos_d   = Vec( 0.0, 0.0, 0.0);
	ivel_d   = Vec( 0.0, 0.0, 0.0);
	ivel     = Vec( 0.0, 0.0, 0.0);
	quat_d   = Quat( 0.0, 0.0, 0.0, 0.0);
	angMom   = Vec( 0.0, 0.0, 0.0);
	uvw      = Vec( 0.0, 0.0, 0.0);
	t_detent_release = -1.0;

	aphi = 0.0;
	alph  = 0.0;
	alphp = 0.0;
	alphy = 0.0;

	g_load_yz_mag = 0.0;
	g_load_yz_max = 0.0;

	//Initial Euler Angles from NEDgtoBODY
	euler = re_factored_geo->NEDgtoBODY.getEuler();
	Vec euler_deg = euler * rtd;
	euler_deg.extract( roll, pitch, yaw );
	//
	//Initial Euler Angles from NEDbtoBODY
	eulerNbtoB = re_factored_geo->NEDbtoBODY.getEuler();
	Vec eulerNbtoB_deg = eulerNbtoB * rtd;
	eulerNbtoB_deg.extract( NEDbtoBODY_roll, NEDbtoBODY_pitch, NEDbtoBODY_yaw );
	//
	//Initial Euler Angles from LTFtoBODY
	eulerLTF = re_factored_geo->LTFtoBODY.getEuler();
	Vec eulerLTF_deg = eulerLTF * rtd;
	eulerLTF_deg.extract( LTFtoBODY_roll, LTFtoBODY_pitch, LTFtoBODY_yaw );
	eulerLTF.extract( LTFtoBODY_roll_r, LTFtoBODY_pitch_r, LTFtoBODY_yaw_r );

	//Initial ECEF Position/Velocity
	epos = re_factored_geo->lla2ecef(re_factored_geo->latg, re_factored_geo->lon, re_factored_geo->altg);
	
	lat0_deg = lat0;
	lon0_deg = lon0;
	alt0_meters = alt0;
	epos_i = re_factored_geo->lla2ecef(
		lat0 * dtr,
		lon0 * dtr,
		alt0
	); // ECEF position of LTF origin
	//
	evel = Vec(0.0, 0.0, 0.0);

	//Initial NEDg Position/Velocity
	npos_i = Vec(0.0, 0.0, -1.0 * alt0); // NED position of LTF origin

	//Calculate NEDg Position Relative to LTF origin
	delPos = (epos - epos_i);
	//
	npos   = (re_factored_geo->ECEFtoNEDg * delPos) + npos_i;
	npos_0 = npos;
	//
	nvel = re_factored_geo->ECEFtoNEDg * evel;

	// Initialize LTF Position/Velocity
	ltf_pos = re_factored_geo->NEDtoLTF * (npos - npos_i);
	XYZ_pos.x = ltf_pos.x;
	XYZ_pos.y = ltf_pos.y;
	XYZ_pos.z = -1 * ltf_pos.z;
	ltf_vel = re_factored_geo->NEDtoLTF * nvel;
	
	//Initial ECI Position/Velocity
	initECI(epos, evel, re_factored_geo->ECItoECEF, ipos, ivel);

	//Initialize Body Rotation States to Earth Rotation
	omegaB = re_factored_geo->ECItoBODY * Vec(0.0, 0.0, omegae);

	//Initial Range
	rng += delPos.mag(); 

	//Initial Attitude Quaternion
	quat = re_factored_geo->ECItoBODY.getQuat();

	//Initial Body-Relative Velocity
	vb   = re_factored_geo->NEDgtoBODY * nvel;
	vrel = vb.mag();

	//Update ECEF Position
	epos  = re_factored_geo->ECItoECEF * ipos;
	
	//Calculate Gravity in ECEF Frame
	egrav = re_factored_geo->gravity(epos);
	
	//Calculate Gravity in ECI Frame
	igrav = re_factored_geo->ECItoECEF.transpose() * egrav;
	
	//Calculate Gravity in Body Frame
	bgrav = re_factored_geo->ECItoBODY * igrav;

	//Normal Force while Missile on Launcher
	massIn = 9.65; // Rough estimate of starting mass.
	Nx =  -1 * massIn * bgrav.x;
	Ny = -1 * massIn * bgrav.y;
	Nz = -1 * massIn * bgrav.z;

	//Initialize G-Load
	g_load = Vec(0.0, 0.0, 0.0);

	//Tolerance
	tol = 1.0e-3;

	//Tipoff Flag
	tip_Flag = -1;

	//Rail Flag
	rail_Flag = -1;

	//Pitch-tumble Flag
	pos_pitch_Flag = -1;
	neg_pitch_Flag = -1;
	pitch_tumble_Flag = -1;

	//Yaw-tumble Flag
	pos_yaw_Flag = -1;
	neg_yaw_Flag = -1;
	yaw_tumble_Flag = -1;

	//Pitch-Yaw-Tumble Flag
	pitch_yaw_tumble_Flag = -1;

	// Error zero for now.
	wpo_mean = 0.0;
	wqo_mean = 0.0;
	wro_mean = 0.0;
	wpo_err = 0.0;
	wqo_err = 0.0;
	wro_err = 0.0;

	railLength = launchRailLength;

	motionMissileTimeOfFlight = 0.0;
	breakWireFlag = -1;
	launch = false;

	// Zero out  integrator values.
	INTEGRATION_METHOD = integrationMethod;
	INTEGRATION_PASS = 0;

	P0 = Vec(0.0, 0.0, 0.0);
	V0 = Vec(0.0, 0.0, 0.0);
	W0 = Vec(0.0, 0.0, 0.0);
	Q0 = Quat(0.0, 0.0, 0.0, 0.0);

	A1 = Vec(0.0, 0.0, 0.0);
	WD1 = Vec(0.0, 0.0, 0.0);
	QD1 = Quat(0.0, 0.0, 0.0, 0.0);
	P1 = Vec(0.0, 0.0, 0.0);
	V1 = Vec(0.0, 0.0, 0.0);
	W1 = Vec(0.0, 0.0, 0.0);
	Q1 = Quat(0.0, 0.0, 0.0, 0.0);

	A2 = Vec(0.0, 0.0, 0.0);
	WD2 = Vec(0.0, 0.0, 0.0);
	QD2 = Quat(0.0, 0.0, 0.0, 0.0);
	P2 = Vec(0.0, 0.0, 0.0);
	V2 = Vec(0.0, 0.0, 0.0);
	W2 = Vec(0.0, 0.0, 0.0);
	Q2 = Quat(0.0, 0.0, 0.0, 0.0);

	A3 = Vec(0.0, 0.0, 0.0);
	WD3 = Vec(0.0, 0.0, 0.0);
	QD3 = Quat(0.0, 0.0, 0.0, 0.0);
	P3 = Vec(0.0, 0.0, 0.0);
	V3 = Vec(0.0, 0.0, 0.0);
	W3 = Vec(0.0, 0.0, 0.0);
	Q3 = Quat(0.0, 0.0, 0.0, 0.0);

};

void Motion::eulerIntegrateStates()
{

	// Integrate.
	P0 = ipos;
	V0 = ivel;
	W0 = omegaB;
	Q0 = quat;

	A1 = ivel_d;
	WD1 = omegaB_d;
	QD1 = quat_d;

	P1.x = P0.x + V0.x * missileTimeOfFlightStep;
	P1.y = P0.y + V0.y * missileTimeOfFlightStep;
	P1.z = P0.z + V0.z * missileTimeOfFlightStep;

	V1.x = V0.x + A1.x * missileTimeOfFlightStep;
	V1.y = V0.y + A1.y * missileTimeOfFlightStep;
	V1.z = V0.z + A1.z * missileTimeOfFlightStep;

	W1.x = W0.x + WD1.x * missileTimeOfFlightStep;
	W1.y = W0.y + WD1.y * missileTimeOfFlightStep;
	W1.z = W0.z + WD1.z * missileTimeOfFlightStep;

	Q1[0] = Q0[0] +QD1[0] * missileTimeOfFlightStep;
	Q1[1] = Q0[1] + QD1[1] * missileTimeOfFlightStep;
	Q1[2] = Q0[2] + QD1[2] * missileTimeOfFlightStep;
	Q1[3] = Q0[3] + QD1[3] * missileTimeOfFlightStep;

	ipos = P1;
	ivel = V1;
	omegaB = W1;
	quat = Q1;

	if (launch)
	{
		motionMissileTimeOfFlight += missileTimeOfFlightStep;
	}

	// Zero out values.
	INTEGRATION_PASS = 0;

	P0 = Vec(0.0, 0.0, 0.0);
	V0 = Vec(0.0, 0.0, 0.0);
	W0 = Vec(0.0, 0.0, 0.0);
	Q0 = Quat(0.0, 0.0, 0.0, 0.0);

	A1 = Vec(0.0, 0.0, 0.0);
	WD1 = Vec(0.0, 0.0, 0.0);
	QD1 = Quat(0.0, 0.0, 0.0, 0.0);
	P1 = Vec(0.0, 0.0, 0.0);
	V1 = Vec(0.0, 0.0, 0.0);
	W1 = Vec(0.0, 0.0, 0.0);
	Q1 = Quat(0.0, 0.0, 0.0, 0.0);

}

void Motion::rk2IntegrateStates()
{
	if (INTEGRATION_PASS == 0)
	{

		P0 = ipos;
		V0 = ivel;
		W0 = omegaB;
		Q0 = quat;

		A1 = ivel_d;
		WD1 = omegaB_d;
		QD1 = quat_d;

		P1.x = P0.x + V0.x * (missileTimeOfFlightStep / 2.0);
		P1.y = P0.y + V0.y * (missileTimeOfFlightStep / 2.0);
		P1.z = P0.z + V0.z * (missileTimeOfFlightStep / 2.0);

		V1.x = V0.x + A1.x * (missileTimeOfFlightStep / 2.0);
		V1.y = V0.y + A1.y * (missileTimeOfFlightStep / 2.0);
		V1.z = V0.z + A1.z * (missileTimeOfFlightStep / 2.0);

		W1.x = W0.x + WD1.x * (missileTimeOfFlightStep / 2.0);
		W1.y = W0.y + WD1.y * (missileTimeOfFlightStep / 2.0);
		W1.z = W0.z + WD1.z * (missileTimeOfFlightStep / 2.0);

		Q1[0] = Q0[0] +QD1[0] * (missileTimeOfFlightStep / 2.0);
		Q1[1] = Q0[1] + QD1[1] * (missileTimeOfFlightStep / 2.0);
		Q1[2] = Q0[2] + QD1[2] * (missileTimeOfFlightStep / 2.0);
		Q1[3] = Q0[3] + QD1[3] * (missileTimeOfFlightStep / 2.0);

		ipos = P1;
		ivel = V1;
		omegaB = W1; 
		quat = Q1;

		INTEGRATION_PASS += 1;
		if (launch)
		{
			motionMissileTimeOfFlight += (missileTimeOfFlightStep / 2.0);
		}
		

	}
	else if (INTEGRATION_PASS == 1)
	{

		A2 = ivel_d;
		WD2 = omegaB_d;
		QD2 = quat_d;

		P2.x = P0.x + V1.x * (missileTimeOfFlightStep);
		P2.y = P0.y + V1.y * (missileTimeOfFlightStep);
		P2.z = P0.z + V1.z * (missileTimeOfFlightStep);

		V2.x = V0.x + A2.x * (missileTimeOfFlightStep);
		V2.y = V0.y + A2.y * (missileTimeOfFlightStep);
		V2.z = V0.z + A2.z * (missileTimeOfFlightStep);

		W2.x = W0.x + WD2.x * (missileTimeOfFlightStep);
		W2.y = W0.y + WD2.y * (missileTimeOfFlightStep);
		W2.z = W0.z + WD2.z * (missileTimeOfFlightStep);

		Q2[0] = Q0[0] +QD2[0] * (missileTimeOfFlightStep);
		Q2[1] = Q0[1] + QD2[1] * (missileTimeOfFlightStep);
		Q2[2] = Q0[2] + QD2[2] * (missileTimeOfFlightStep);
		Q2[3] = Q0[3] + QD2[3] * (missileTimeOfFlightStep);

		ipos = P2;
		ivel = V2;
		omegaB = W2;
		quat = Q2;

		if (launch)
		{
			motionMissileTimeOfFlight += (missileTimeOfFlightStep / 2.0);
		}


		// Zero out values.
		INTEGRATION_PASS = 0;

		P0 = Vec(0.0, 0.0, 0.0);
		V0 = Vec(0.0, 0.0, 0.0);
		W0 = Vec(0.0, 0.0, 0.0);
		Q0 = Quat(0.0, 0.0, 0.0, 0.0);

		A1 = Vec(0.0, 0.0, 0.0);
		WD1 = Vec(0.0, 0.0, 0.0);
		QD1 = Quat(0.0, 0.0, 0.0, 0.0);
		P1 = Vec(0.0, 0.0, 0.0);
		V1 = Vec(0.0, 0.0, 0.0);
		W1 = Vec(0.0, 0.0, 0.0);
		Q1 = Quat(0.0, 0.0, 0.0, 0.0);

		A2 = Vec(0.0, 0.0, 0.0);
		WD2 = Vec(0.0, 0.0, 0.0);
		QD2 = Quat(0.0, 0.0, 0.0, 0.0);
		P2 = Vec(0.0, 0.0, 0.0);
		V2 = Vec(0.0, 0.0, 0.0);
		W2 = Vec(0.0, 0.0, 0.0);
		Q2 = Quat(0.0, 0.0, 0.0, 0.0);

	}
}

void Motion::rk4IntegrateStates()
{

	if (INTEGRATION_PASS == 0)
	{

		P0 = ipos;
		V0 = ivel;
		W0 = omegaB;
		Q0 = quat;

		A1 = ivel_d;
		WD1 = omegaB_d;
		QD1 = quat_d;

		P1.x = P0.x + V0.x * (missileTimeOfFlightStep / 2.0);
		P1.y = P0.y + V0.y * (missileTimeOfFlightStep / 2.0);
		P1.z = P0.z + V0.z * (missileTimeOfFlightStep / 2.0);

		V1.x = V0.x + A1.x * (missileTimeOfFlightStep / 2.0);
		V1.y = V0.y + A1.y * (missileTimeOfFlightStep / 2.0);
		V1.z = V0.z + A1.z * (missileTimeOfFlightStep / 2.0);

		W1.x = W0.x + WD1.x * (missileTimeOfFlightStep / 2.0);
		W1.y = W0.y + WD1.y * (missileTimeOfFlightStep / 2.0);
		W1.z = W0.z + WD1.z * (missileTimeOfFlightStep / 2.0);

		Q1[0] = Q0[0] +QD1[0] * (missileTimeOfFlightStep / 2.0);
		Q1[1] = Q0[1] + QD1[1] * (missileTimeOfFlightStep / 2.0);
		Q1[2] = Q0[2] + QD1[2] * (missileTimeOfFlightStep / 2.0);
		Q1[3] = Q0[3] + QD1[3] * (missileTimeOfFlightStep / 2.0);

		ipos = P1;
		ivel = V1;
		omegaB = W1; 
		quat = Q1;

		INTEGRATION_PASS += 1;
		if (launch)
		{
			motionMissileTimeOfFlight += (missileTimeOfFlightStep / 2.0);
		}
		

	}
	else if (INTEGRATION_PASS == 1)
	{

		A2 = ivel_d;
		WD2 = omegaB_d;
		QD2 = quat_d;

		P2.x = P0.x + V1.x * (missileTimeOfFlightStep / 2.0);
		P2.y = P0.y + V1.y * (missileTimeOfFlightStep / 2.0);
		P2.z = P0.z + V1.z * (missileTimeOfFlightStep / 2.0);

		V2.x = V0.x + A2.x * (missileTimeOfFlightStep / 2.0);
		V2.y = V0.y + A2.y * (missileTimeOfFlightStep / 2.0);
		V2.z = V0.z + A2.z * (missileTimeOfFlightStep / 2.0);

		W2.x = W0.x + WD2.x * (missileTimeOfFlightStep / 2.0);
		W2.y = W0.y + WD2.y * (missileTimeOfFlightStep / 2.0);
		W2.z = W0.z + WD2.z * (missileTimeOfFlightStep / 2.0);

		Q2[0] = Q0[0] +QD2[0] * (missileTimeOfFlightStep / 2.0);
		Q2[1] = Q0[1] + QD2[1] * (missileTimeOfFlightStep / 2.0);
		Q2[2] = Q0[2] + QD2[2] * (missileTimeOfFlightStep / 2.0);
		Q2[3] = Q0[3] + QD2[3] * (missileTimeOfFlightStep / 2.0);

		ipos = P2;
		ivel = V2;
		omegaB = W2; 
		quat = Q2;

		INTEGRATION_PASS += 1;

	}
	else if (INTEGRATION_PASS == 2)
	{

		A3 = ivel_d;
		WD3 = omegaB_d;
		QD3 = quat_d;

		P3.x = P0.x + V2.x * (missileTimeOfFlightStep);
		P3.y = P0.y + V2.y * (missileTimeOfFlightStep);
		P3.z = P0.z + V2.z * (missileTimeOfFlightStep);

		V3.x = V0.x + A3.x * (missileTimeOfFlightStep);
		V3.y = V0.y + A3.y * (missileTimeOfFlightStep);
		V3.z = V0.z + A3.z * (missileTimeOfFlightStep);

		W3.x = W0.x + WD3.x * (missileTimeOfFlightStep);
		W3.y = W0.y + WD3.y * (missileTimeOfFlightStep);
		W3.z = W0.z + WD3.z * (missileTimeOfFlightStep);

		Q3[0] = Q0[0] +QD3[0] * (missileTimeOfFlightStep);
		Q3[1] = Q0[1] + QD3[1] * (missileTimeOfFlightStep);
		Q3[2] = Q0[2] + QD3[2] * (missileTimeOfFlightStep);
		Q3[3] = Q0[3] + QD3[3] * (missileTimeOfFlightStep);

		ipos = P3;
		ivel = V3;
		omegaB = W3; 
		quat = Q3;

		INTEGRATION_PASS += 1;
		if (launch)
		{
			motionMissileTimeOfFlight += (missileTimeOfFlightStep / 2.0);
		}
		

	}
	else if (INTEGRATION_PASS == 3)
	{

		A4 = ivel_d;
		WD4 = omegaB_d;
		QD4 = quat_d;

		P4.x = P0.x + (V0.x + V1.x * 2.0 + V2.x * 2.0 + V3.x) * (missileTimeOfFlightStep / 6.0);
		P4.y = P0.y + (V0.y + V1.y * 2.0 + V2.y * 2.0 + V3.y) * (missileTimeOfFlightStep / 6.0);
		P4.z = P0.z + (V0.z + V1.z * 2.0 + V2.z * 2.0 + V3.z) * (missileTimeOfFlightStep / 6.0);

		V4.x = V0.x + (A1.x + A2.x * 2.0 + A3.x * 2.0 + A4.x) * (missileTimeOfFlightStep / 6.0);
		V4.y = V0.y + (A1.y + A2.y * 2.0 + A3.y * 2.0 + A4.y) * (missileTimeOfFlightStep / 6.0);
		V4.z = V0.z + (A1.z + A2.z * 2.0 + A3.z * 2.0 + A4.z) * (missileTimeOfFlightStep / 6.0);

		W4.x = W0.x + (WD1.x + WD2.x * 2.0 + WD3.x * 2.0 + WD4.x) * (missileTimeOfFlightStep / 6.0);
		W4.y = W0.y + (WD1.y + WD2.y * 2.0 + WD3.y * 2.0 + WD4.y) * (missileTimeOfFlightStep / 6.0);
		W4.z = W0.z + (WD1.z + WD2.z * 2.0 + WD3.z * 2.0 + WD4.z) * (missileTimeOfFlightStep / 6.0);

		Q4[0] = Q0[0] + (QD1[0] + QD2[0] * 2.0 + QD3[0] * 2.0 + QD4[0]) * (missileTimeOfFlightStep / 6.0);
		Q4[1] = Q0[1] + (QD1[1] + QD2[1] * 2.0 + QD3[1] * 2.0 + QD4[1]) * (missileTimeOfFlightStep / 6.0);
		Q4[2] = Q0[2] + (QD1[2] + QD2[2] * 2.0 + QD3[2] * 2.0 + QD4[2]) * (missileTimeOfFlightStep / 6.0);
		Q4[3] = Q0[3] + (QD1[3] + QD2[3] * 2.0 + QD3[3] * 2.0 + QD4[3]) * (missileTimeOfFlightStep / 6.0);

		ipos = P4;
		ivel = V4;
		omegaB = W4; 
		quat = Q4;

		// Zero out values.
		INTEGRATION_PASS = 0;

		P0 = Vec(0.0, 0.0, 0.0);
		V0 = Vec(0.0, 0.0, 0.0);
		W0 = Vec(0.0, 0.0, 0.0);
		Q0 = Quat(0.0, 0.0, 0.0, 0.0);

		A1 = Vec(0.0, 0.0, 0.0);
		WD1 = Vec(0.0, 0.0, 0.0);
		QD1 = Quat(0.0, 0.0, 0.0, 0.0);
		P1 = Vec(0.0, 0.0, 0.0);
		V1 = Vec(0.0, 0.0, 0.0);
		W1 = Vec(0.0, 0.0, 0.0);
		Q1 = Quat(0.0, 0.0, 0.0, 0.0);

		A2 = Vec(0.0, 0.0, 0.0);
		WD2 = Vec(0.0, 0.0, 0.0);
		QD2 = Quat(0.0, 0.0, 0.0, 0.0);
		P2 = Vec(0.0, 0.0, 0.0);
		V2 = Vec(0.0, 0.0, 0.0);
		W2 = Vec(0.0, 0.0, 0.0);
		Q2 = Quat(0.0, 0.0, 0.0, 0.0);

		A3 = Vec(0.0, 0.0, 0.0);
		WD3 = Vec(0.0, 0.0, 0.0);
		QD3 = Quat(0.0, 0.0, 0.0, 0.0);
		P3 = Vec(0.0, 0.0, 0.0);
		V3 = Vec(0.0, 0.0, 0.0);
		W3 = Vec(0.0, 0.0, 0.0);
		Q3 = Quat(0.0, 0.0, 0.0, 0.0);

		A4 = Vec(0.0, 0.0, 0.0);
		WD4 = Vec(0.0, 0.0, 0.0);
		QD4 = Quat(0.0, 0.0, 0.0, 0.0);
		P4 = Vec(0.0, 0.0, 0.0);
		V4 = Vec(0.0, 0.0, 0.0);
		W4 = Vec(0.0, 0.0, 0.0);
		Q4 = Quat(0.0, 0.0, 0.0, 0.0);

	}
}

void Motion::setNewNavigationState(
	NavigationState const &navigationState,
	Vec LTFWindVel,
	Vec aeroForce,
	Vec aeroMoment,
	Vec motorForce,
	Vec motorMoment,
	double mass,
	Mat inertiaTensor
)
{

	// Input
	simulationTime = navigationState.simulationTime_;
	LTFWindVelocityIn = LTFWindVel;
	aeroForceIn = aeroForce;
	aeroMomentIn = aeroMoment;
	motorForceIn = motorForce;
	motorMomentIn = motorMoment;
	massIn = mass;
	inertiaTensorIn = inertiaTensor;

	// Update geometry.
	re_factored_geo->update(simulationTime, quat);

	//Sum Forces and Moments
	SumForcesMoments();

	//Calculate 6DOF States
	Calc_6DOF();

	//Update Truth States
	UpdateTruth(LTFWindVelocityIn);

	if (INTEGRATION_METHOD == 0)
	{
		eulerIntegrateStates();
	}
	else if (INTEGRATION_METHOD == 1)
	{
		rk2IntegrateStates();
	}
	else if (INTEGRATION_METHOD == 2)
	{
		rk4IntegrateStates();
	}

	if (simulationTime > breakWireDelay && INTEGRATION_PASS == 0)
	{
		if (launch == false)
		{
			launch = true;
		}
	}

}

void Motion::SumForcesMoments()
{

	//Assign Induced Roll
	if(spinFlag == 1)
	{ //Induced Roll from Spin Vanes
		if((rail_Flag == 1) && (motionMissileTimeOfFlight <= rocketBurnOut))
		{
			motorMomentIn.x = inducedMoment();
		}
	}

	//Sum Forces
	force.x  = aeroForceIn.x + motorForceIn.x;
	force.y  = aeroForceIn.y + motorForceIn.y;
	force.z  = aeroForceIn.z + motorForceIn.z;
	
	//Sum Moments
	moment.x = aeroMomentIn.x + motorMomentIn.x;
	moment.y = aeroMomentIn.y + motorMomentIn.y;
	moment.z = aeroMomentIn.z + motorMomentIn.z;

}

//--------------------------------------------------------//

void Motion::Calc_6DOF()
{

	//Update ECEF Position
	epos  = re_factored_geo->ECItoECEF * ipos;

	//Calculate Gravity in ECEF Frame
	egrav = re_factored_geo->gravity(epos);

	//Calculate Gravity in ECI Frame
	igrav = re_factored_geo->ECItoECEF.transpose() * egrav;
	
	//Calculate Gravity in Body Frame
	bgrav = re_factored_geo->ECItoBODY * igrav;

	//Compute ECI Linear Velocity (Position Derivative)
	ipos_d = ivel;

	//Transform Summed Forces into ECI Frame
	sumF_ECI = re_factored_geo->ECItoBODY.transpose() * force;

	//Range from Launch
	rng = Vec(epos - epos_i).mag();

	//Constraints while missile in tube
	double rng_xy = sqrt((npos.x-npos_0.x)*(npos.x-npos_0.x) + (npos.y-npos_0.y)*(npos.y-npos_0.y));

	if(rng_xy <= railLength)
	{

		//Zero Moments
		moment( 0.0, 0.0, 0.0);

		//Apply Earth-Rate while missile in launcher
		omegaB = re_factored_geo->ECItoBODY * Vec(0.0, 0.0, omegae);

	}
	else
	{

		//Free Flight Mode
		if(rail_Flag == -1)
		{ 
			timeOfFlightClearOfRail = motionMissileTimeOfFlight;
			rail_Flag =  1;
		}

		//Normal Force no longer valid since missile not on launcher
		Nx = 0.0;
		Ny = 0.0;
		Nz = 0.0;
	}

	//Missile Constrained by Normal Force and Detent Force
	if(!launch)
	{

		//Compute ECI Linear Acceleration (Velocity Derivatives)
		//On Launcher
		omegaI  = re_factored_geo->ECItoBODY.transpose() * omegaB;
		Vec wXr = omegaI.cross(ipos);
		ivel_d = omegaI.cross(wXr);

	}
	else
	{

		//Compute ECI Linear Acceleration (Velocity Derivatives)
		//During Free-Flight
		ivel_d = sumF_ECI/massIn + igrav;

		// If detent force exceeded, start breakwire timer
		if (t_detent_release < 0.0)
		{
			t_detent_release = simulationTime;
		}

	}

	//Apply Tip-off at Tube Exit
	if(rng_xy > railLength && tip_Flag == -1)
	{
		//Add Tipoff to body-rates
		tipoff.x = (wpo_mean +  wpo_err) * rtd;
		tipoff.y = (wqo_mean +  wqo_err*cos(re_factored_geo->phiLnch) + wro_err*sin(re_factored_geo->phiLnch)) * rtd;
		tipoff.z = (wro_mean + -wqo_err*sin(re_factored_geo->phiLnch) + wro_err*cos(re_factored_geo->phiLnch)) * rtd;
		omegaB.x = omegaB.x + tipoff.x*dtr;
		omegaB.y = omegaB.y + tipoff.y*dtr;
		omegaB.z = omegaB.z + tipoff.z*dtr;
		tip_Flag = 1;
	}

	//----------------------------------------------------------------------//
	//                                                                      //
	//     Body-Relative Rotational Accelerations (Non-Symmetric Missile)   // 
	//     ==================================    // 
	//                                                                      // 
	//        --- MOMENT VECTOR ---                                         // 
	//                        .                                             // 
	//        _               _       _              _                      // 
	//        M    =   iten * w   +   w  X  ( iten * w )                    // 
	//                         b       b              b                     // 
	//                                                                      // 
	//        --- SOLVE FOR WDOT ---                                        // 
	//        .                                                             // 
	//        _            -1     _       _              _                  // 
	//        w    =   iten   * ( M   -   w  X  ( iten * w )                // 
	//         b                           b              b                 // 
	//----------------------------------------------------------------------//

	//Calculate Angular Momentum (h = iten * w)
	angMom = inertiaTensorIn * omegaB;

	//Calculate Nutation (coning) Angle (angle btwn body-axis and angular momentum vector)
	Vec xbod = Vec(1.0, 0.0, 0.0);
	conAng   = vecAng(xbod, angMom);

	//Check for tumble conditions
	checkTumble();

	//w X h
	Vec wXh = omegaB.cross(angMom);

	//Calculate Body Rotational Accelerations (wdot)
	omegaB_d     = inertiaTensorIn.inv() * (moment - wXh);

	//Quaternion Derivative
	quat_d[0] = -0.5 * ( omegaB.x * quat[1] + omegaB.y * quat[2] + omegaB.z * quat[3]);
	quat_d[1] =  0.5 * ( omegaB.x * quat[0] - omegaB.y * quat[3] + omegaB.z * quat[2]);
	quat_d[2] =  0.5 * ( omegaB.x * quat[3] + omegaB.y * quat[0] - omegaB.z * quat[1]);
	quat_d[3] = -0.5 * ( omegaB.x * quat[2] - omegaB.y * quat[1] - omegaB.z * quat[0]);

	//Normalize Quaternion
	quat = quat.normalize();

}

//--------------------------------------------------------//

void Motion::UpdateTruth(Vec LTFWindVel)
{

	cout.precision(12);

	//Specific Force Acceleration (used by IMU)
	if(rail_Flag != 1)
	{
		//Subtract off gravity if still on launcher
		sf_b = re_factored_geo->ECItoBODY * (ivel_d - igrav);
	}
	else
	{
		sf_b = force/massIn;
	}

	//G-Load
	g_load = sf_b/G;

	g_load_yz_mag = pow((pow(g_load.z, 2.0) + pow(g_load.y, 2.0)), 0.5);

	if(g_load_yz_mag > g_load_yz_max)
	{
		g_load_yz_max = g_load_yz_mag;
	}

	//Update ECEF Position/Velocity
	update_ECEF(ipos, ivel, re_factored_geo->ECItoECEF, epos, evel);

	//Compute ECEF linear Accelerations
	evel_d = re_factored_geo->ECItoECEF * ivel_d;

	//Update Body Frame Velocities (no wind)
	uvw = re_factored_geo->ECEFtoBODY * evel;

	//Compute Relative Velocity in Body-Relative Coordinates
	//(used in Aero for calculating Alpha and Beta)
	//This is the velocity of the missile with respect to the wind velocity
	//(ie. vrel = missile velocity in body - wind velocity in body)
	Vec vwindb = re_factored_geo->LTFtoBODY * LTFWindVel;
	vb       = uvw - vwindb;
	vrel     = vb.mag();

	//Angle of Attack
	angle_of_attack( vb, alphp, alphy, alph, aphi);

	//Update Euler Angles from NEDgtoBODY and NEDbtoBODY
	euler = re_factored_geo->NEDgtoBODY.getEuler();
	Vec euler_deg = euler * rtd;
	euler_deg.extract( roll, pitch, yaw );
	//
	eulerNbtoB = re_factored_geo->NEDbtoBODY.getEuler();
	Vec eulerNbtoB_deg = eulerNbtoB * rtd;
	eulerNbtoB_deg.extract( NEDbtoBODY_roll, NEDbtoBODY_pitch, NEDbtoBODY_yaw);
	eulerNbtoB.extract( NEDbtoBODY_roll_rad, NEDbtoBODY_pitch_rad, NEDbtoBODY_yaw_rad);

	//Determine Geodetic Latitude, Longitude and Altitude
	re_factored_geo->ecef2lla(epos, &re_factored_geo->latg, &re_factored_geo->lon, &re_factored_geo->altg);

	//Calculate NED Velocity
	nvel = re_factored_geo->ECEFtoNEDb * evel;

	// //Calculate Flight Path Angles
	// if(nvel.mag() <= tol)
	// {
	// 	gamH = 0.0;
	// 	gamV = 0.0;
	// }
	// else
	// {
	// 	gamH = atan2(ltf_vel.y, ltf_vel.x)*rtd;
	// 	gamV = asin(-ltf_vel.z/ltf_vel.mag())*rtd;
	// }

	//Calculate NEDg Position Relative to LTF origin
	delPos = (epos - epos_i);

	npos   = (re_factored_geo->ECEFtoNEDg * delPos) + npos_i;

	//Calculate Launch-Tangent-Frame (LTF) Relative to LTF origin
	ltf_pos = re_factored_geo->NEDtoLTF * (npos - npos_i);
	XYZ_pos.x = ltf_pos.x;
	XYZ_pos.y = ltf_pos.y;
	XYZ_pos.z = -1 * ltf_pos.z;
	ltf_vel = re_factored_geo->NEDtoLTF * nvel;
	//
	//Update Euler Angles from LTFtoBODY
	eulerLTF = re_factored_geo->LTFtoBODY.getEuler();
	Vec eulerLTF_deg = eulerLTF * rtd;
	eulerLTF_deg.extract( LTFtoBODY_roll, LTFtoBODY_pitch, LTFtoBODY_yaw );
	eulerLTF.extract( LTFtoBODY_roll_r, LTFtoBODY_pitch_r, LTFtoBODY_yaw_r );

}

//--------------------------------------------------------//

void Motion::initECI(Vec epos, Vec evel, Mat i2e, Vec &ipos, Vec &ivel)
{

	//---------------------------------------------------------//
	// Calcuates ECEF states from ECI states with
	// coordinate transformation and relative velocity vector
	//
	// Input:   ipos - position vector in ECI frame
	//          ivel - velocity vector in ECI frame
	//
	// Output:  epos - position vector in ECEF frame
	//          evel - velocity vector in ECEF frame
	//
	// Developer: Dennis Strickland
	//---------------------------------------------------------//

	//Transform ECEF position to ECI position
	ipos = i2e.transpose() * epos;

	//Transform ECEF velocity to ECI velocity
	Vec i_ivel = i2e.transpose() * evel;

	//Calculate local velocity (wxR)
	Vec omeg = Vec(0.0, 0.0, omegae);
	Vec wXr  = omeg.cross(ipos);

	//Add local velocity of ECEF frame to get true ECI velocities
	ivel = i_ivel + wXr;
}


//--------------------------------------------------------//
void Motion:: checkTumble()
{

	//Checks for various tumble conditions
	
	
	///////////
	//Calculate tumble condition based on pitch/yaw angles
	//
	//
	//Check if pitch hits in the range of +/- 90 deg

	if (pitch >= (90.0 - deg_tol))
	{
		pos_pitch_Flag = 1;
	}


	if (pitch <= (-90.0 + deg_tol))
	{
		neg_pitch_Flag = 1;
	}

	if ((pos_pitch_Flag == 1) && (neg_pitch_Flag == 1))
	{
		pitch_tumble_Flag = 1;
	}

	//Check if yaw hits in the range of +/- 180 degrees
	
	if(  yaw >= (180.0 - deg_tol) )
	{
		pos_yaw_Flag = 1;
	}

	if(  yaw <= (-180.0 + deg_tol) )
	{
		neg_yaw_Flag = 1;
	}

	if ( (pos_yaw_Flag == 1) && (neg_yaw_Flag == 1))
	{
		yaw_tumble_Flag = 1;
	}

	// If pitch or yaw tumble flag activated
	if ( (pitch_tumble_Flag == 1) || (yaw_tumble_Flag == 1))
	{
		pitch_yaw_tumble_Flag = 1;
	}
	//////////////////////////////

	//Calculate Precession Rate (deg/s)
	if((simulationTime >= rocketBurnOut) && ((abs(conAng) <= 90.0-cangTol) || (abs(conAng) >= 90.0+cangTol)) )
	{
		precRate = (inertiaTensorIn[0][0]*omegaB.x / ((inertiaTensorIn[1][1]-inertiaTensorIn[0][0])*cos(conAng*dtr)))*rtd;
	
		//Calculate Prec Rate 2 based on derivatives of rpy
		if ((pitch >= abs(89.0) && (pitch <= abs(91.0))))
		{
			yaw_d = 0.0;
		}
		else
		{
			yaw_d = ((omegaB.y * sin(roll*dtr)) + (omegaB.z * cos(yaw*dtr)))/cos(pitch*dtr);
		}

		roll_d = omegaB.x + yaw_d * sin(pitch*dtr);
		pitch_d = (omegaB.y * cos(roll*dtr)) - (omegaB.z * sin(roll*dtr));

		precRate2 = (pow( (pow(yaw_d, 2.0) + pow(pitch_d, 2.0)), 0.5)) * rtd;
	}
	else
	{
		precRate = 0.0;
		precRate2 = 0.0;
	}

}

//--------------------------------------------------------//

void Motion::update_ECEF(Vec ipos, Vec ivel, Mat i2e, Vec &epos, Vec &evel)
{

	//---------------------------------------------------------//
	// Calcuates ECEF states from ECI states with
	// coordinate transformation and relative velocity vector
	//
	// Input:   ipos - position vector in ECI frame
	//          ivel - velocity vector in ECI frame
	//
	// Output:  epos - position vector in ECEF frame
	//          evel - velocity vector in ECEF frame
	//
	// Developer: Dennis Strickland
	//---------------------------------------------------------//

	//Transform ECI position to ECEF position
	epos = i2e * ipos;

	//Transform ECI velocity to ECEF velocity
	//(still inertial at this point)
	Vec i_evel = i2e * ivel;

	//Calculate local velocity (wxR)
	Vec omeg = Vec(0.0, 0.0, omegae);
	Vec wXr  = omeg.cross(epos);

	//Subtract local velocity of ECI frame to get true ECEF velocities
	evel = i_evel - wXr;
}

//-------------------------------------------------//

double Motion::vecAng( Vec x, Vec y)
{

	double arg, ang;
	double tol = 1.0e-12;

	double dot  = x.dot(y);
	double xmag = x.mag();
	double ymag = y.mag();

	if((dot > -tol) && (dot < tol))
	{
		dot = 0.0;
	}

	if((xmag == 0.0) || (ymag == 0.0))
	{
		arg = 1.0;
	}
	else
	{
		arg = dot/(xmag*ymag);
	}

	//Angle between vectors
	ang = asin(arg)*rtd;

	return ang;
}

//-------------------------------------------------//

void Motion::angle_of_attack(Vec v_b, double &alphp, double &alphy, double &alpha, double &aphi)
{

	alphp = atan2_0( v_b.z, v_b.x) * rtd;
	if( v_b.mag() == 0.0)
	{
		alphy = 0.0;
	}
	else
	{
		alphy = asin( v_b.y / v_b.mag()) * rtd;
	}

	double yzVel = sqrt( v_b.y * v_b.y + v_b.z * v_b.z);
	if( v_b.x == 0.0)
	{
		alpha = 0.0;
	}
	else
	{
		alpha = atan2_0( yzVel, v_b.x) * rtd;
	}

	//Aero Roll Angle
	aphi = atan2_0(vb.y,vb.z) * rtd;
	if(aphi > 180.0)
	{
		aphi = aphi - 360.0;
	}
	else if(aphi < -180.0)
	{
		aphi = aphi + 360.0;
	}

}

double Motion::atan2_0( double y, double x)
{
	if( x == 0.0 && y == 0.0)
	{
		return 0.0;
	}
	else
	{
		return atan2( y, x);
	} 
}

//-------------------------------------------------//

double Motion::inducedMoment()
{

	double tfree;

	static double prev_delMom;
	static double delMom = 0.0;
	double delT;
	double mom;

	//Curve-fit coefficients
	double A = -303232.0;
	double B =  1.97258e+06;
	double C = -5.3265e+06;
	double D =  7.72015e+06;
	double E = -6.47481e+06;
	double F =  3.14117e+06;
	double G = -821596.0;
	double H =  93981.2;

	//Delta time from free flight
	delT = motionMissileTimeOfFlight - timeOfFlightClearOfRail - missileTimeOfFlightStep;

	//Previous value
	prev_delMom = delMom;

	//Curve-fit of spin-rate
	delMom = (A * (delT)*(delT)*(delT)*(delT)*(delT)*(delT)*(delT)*(delT) +
			B * (delT)*(delT)*(delT)*(delT)*(delT)*(delT)*(delT) +
			C * (delT)*(delT)*(delT)*(delT)*(delT)*(delT) +
			D * (delT)*(delT)*(delT)*(delT)*(delT) +
			E * (delT)*(delT)*(delT)*(delT) +
			F * (delT)*(delT)*(delT) +
			G * (delT)*(delT) +
			H * (delT))* dtr * pScale;

	//Compute roll moment based on spin rate (M = I * pdot)
	if(prev_delMom != 0.0)
	{
		mom = (delMom - prev_delMom) / missileTimeOfFlightStep * inertiaTensorIn[0][0];
	}
	else
	{
		mom = 0.0;
	}

	return mom;

}