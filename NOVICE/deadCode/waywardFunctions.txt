	// // Return.
	// double retPip[3];

	// // Determines return.
	// bool goodShot = false;

	// // Flyout time step.
	// double flyoutTimeStep = 1.0 / 200.0; // Smaller time step for faster flyouts.

	// // Check to see if the target is moving away or toward the missile.
	// int lowIndex = 0;
	// int highIndex = targetTrajectory.size() - 1;

	// TrajectoryPoint firstTrajPoint = targetTrajectory[lowIndex];
	// double firstTrajPointDistance, firstTrajPointRelPos[3];
	// subtractTwoVectors(firstTrajPoint.second.array, missile.ENUPosition, firstTrajPointRelPos);
	// magnitude(firstTrajPointRelPos, firstTrajPointDistance);

	// TrajectoryPoint lastTrajPoint = targetTrajectory[highIndex];
	// double lastTrajPointDistance, lastTrajPointRelPos[3];
	// subtractTwoVectors(lastTrajPoint.second.array, missile.ENUPosition, lastTrajPointRelPos);
	// magnitude(lastTrajPointRelPos, lastTrajPointDistance);

	// // The way it looks for a good shot depends on whether it is moving away or toward the launcher.
	// int increment;
	// int shotCheckIndex;
	// if (lastTrajPointDistance > firstTrajPointDistance) // Moving away.
	// {
	// 	increment = (1 / CONSTANT_TIME_STEP);
	// 	shotCheckIndex = lowIndex + increment;
	// }
	// else // Moving toward you.
	// {
	// 	increment = -1.0 * (1 / CONSTANT_TIME_STEP);
	// 	shotCheckIndex = highIndex + increment;
	// }

	// // Find a good shot.
	// int loopCount = 0;
	// while (not goodShot)
	// {

	// 	loopCount += 1;
	// 	Missile missileCopy = missile;
	// 	TrajectoryPoint currentShot = targetTrajectory[shotCheckIndex];
	// 	Triple currentPip = currentShot.second;
	// 	setArrayEquivalentToReference(missileCopy.pip, currentPip.array);
	// 	initSeeker(missileCopy);
	// 	string id = "flyout" + to_string(loopCount);

	// 	// Check range to target. Works best within five click.
	// 	TrajectoryPoint trajPoint = targetTrajectory[shotCheckIndex];
	// 	double trajPointDistance, trajPointRelPos[3];
	// 	subtractTwoVectors(trajPoint.second.array, missile.ENUPosition, trajPointRelPos);
	// 	magnitude(trajPointRelPos, trajPointDistance);
	// 	if (trajPointDistance < 3000.0 || trajPointDistance > 6000.0)
	// 	{
	// 		shotCheckIndex += increment;
	// 		continue;
	// 	}

	// 	threeDofFly(missileCopy, id, true, false, 400.0);
	// 	double ratio = missileCopy.timeOfFlight / currentShot.first;

	// 	if (showProcess)
	// 	{

	// 		cout << "FLYOUT " << loopCount << endl;
	// 		cout << "TARGET TIME OF FLIGHT " << currentShot.first << endl;
	// 		cout << "MISSILE TIME OF FLIGHT " << missileCopy.timeOfFlight << endl;
	// 		cout << "GOOD SHOT CHECK " << ratio << endl;
	// 		cout << "INDEX " << shotCheckIndex << endl;
	// 		cout << "SIMULATION RESULT " << missileCopy.lethality << endl;
	// 		cout << "\n";

	// 	}

	// 	// We only care about intercepts.
	// 	if (missileCopy.lethality == "SUCCESSFUL_INTERCEPT")
	// 	{
	// 		if (ratio > 1.0) // Too late. Move the target closer.
	// 		{
	// 			shotCheckIndex += increment;
	// 		}
	// 		// The first time this condition is hit it means a good shot is found.
	// 		// Even if the interceptor arrives seconds early the launch will be scheduled.
	// 		// This way the interceptor arrives on time.
	// 		else
	// 		{
	// 			cout << "GOOD SHOT FOUND!\n";
	// 			setArrayEquivalentToReference(retPip, currentPip.array);
	// 			goodShot = true;
	// 		}
	// 	}
	// 	else // Otherwise move the target closer.
	// 	{
	// 		shotCheckIndex += increment;
	// 	}

	// 	if (loopCount > 30) // Any higher and most likely there is no good shot.
	// 	{
	// 		break;
	// 	}

	// }

	// Triple ret(retPip);
	// return ret;


	// Missile Missile1;
	// initUnLaunchedMissile(Missile1, 0.0, 89.0, -20.0);
	// Missile1.pip[0] = 4000.0;
	// Missile1.pip[1] = 0.0;
	// Missile1.pip[2] = 3000.0;
	// Missile Missile2 = Missile1;

	// // Missile1.pip[0] = 3000.0;
	// // Missile1.pip[1] = 1000.0;
	// // Missile1.pip[2] = 3000.0;

	// // sixDofFly(Missile1, "log", true, true, 400.0);
	// // threeDofFly(Missile2, "log", true, true, 400.0);

	// // double targetENUVelocity[3] = {-400.0, 0.0, -450.0};
	// // double targetENUPosition[3] = {10000.0, 0.0, 10000.0};
	// double targetENUVelocity[3] = {500.0, 0.0, 0.0};
	// double targetENUPosition[3] = {-5000.0, 0.0, 3000.0};
	// // double targetENUVelocity[3] = {-800.0, 0.0, 0.0};
	// // double targetENUPosition[3] = {20000.0, 0.0, 3000.0};
	// Trajectory target = propagatePositionAndVelocity(targetENUPosition, targetENUVelocity);
	// Triple missile2Pip = pipSelection(Missile2, target, true);
	// setArrayEquivalentToReference(Missile2.pip, missile2Pip.array);
	// initSeeker(Missile1);
	// sixDofFly(Missile2, "missile2", true, true, 400.0);
