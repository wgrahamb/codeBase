double integrate(double dy_new, double dy, double y, double intStep) {
// 	return y + ((dy_new + dy) * intStep / 2);
// }

// void flightPathAnglesToLocalOrientation (double azimuth, double elevation, double localFrame[3][3]) {
// 	localFrame[0][0] = cos(elevation) * cos(azimuth);
// 	localFrame[0][1] = cos(elevation) * sin(azimuth);
// 	localFrame[0][2] = -1 * sin(elevation);
// 	localFrame[1][0] = -1 * sin(azimuth);
// 	localFrame[1][1] = cos(azimuth);
// 	localFrame[1][2] = 0;
// 	localFrame[2][0] = sin(elevation) * cos(azimuth);
// 	localFrame[2][1] = sin(elevation) * sin(azimuth);
// 	localFrame[2][2] = cos(elevation);
// }

// void eulerAnglesToLocalOrientation (double phi, double theta, double psi, double matrix[3][3]) {
// 	matrix[0][0] = cos(psi) * cos(theta);
// 	matrix[0][1] = sin(psi) * cos(theta);
// 	matrix[0][2] = -1 * sin(theta);
// 	matrix[1][0] = cos(psi) * sin(theta) * sin(phi) - sin(psi) * cos(phi);
// 	matrix[1][1] = sin(psi) * sin(theta) * sin(phi) + cos(psi) * cos(phi);
// 	matrix[1][2] = cos(theta) * sin(phi);
// 	matrix[2][0] = cos(psi) * sin(theta) * cos(phi) + sin(psi) * sin(phi);
// 	matrix[2][1] = sin(psi) * sin(theta) * cos(phi) - cos(psi) * sin(phi);
// 	matrix[2][2] = cos(theta) * cos(phi);
// }

// void unitVec (double vector[3], double unitVector[3]) {
// 	double mag = sqrt(vector[0] * vector[0] + vector[1] * vector[1] + vector[2] * vector[2]);
// 	unitVector[0] = vector[0] / mag;
// 	unitVector[1] = vector[1] / mag;
// 	unitVector[2] = vector[2] / mag;
// }

// void azAndElFromVector (double &az, double &el, double vector[3]) {
// 	az = atan2(vector[1], vector[0]);
// 	double t1 = pow(vector[0], 2);
// 	double t2 = pow(vector[1], 2);
// 	double t3 = sqrt(t1 + t2);
// 	el = atan2(vector[2], t3);
// }

// void oneByThreeTimesThreeByThree(double arr[3], double matrix[3][3], double out[3]) {
// 	out[0] = matrix[0][0] * arr[0] + matrix[1][0] * arr[1] + matrix[2][0] * arr[2];
// 	out[1] = matrix[0][1] * arr[0] + matrix[1][1] * arr[1] + matrix[2][1] * arr[2];
// 	out[2] = matrix[0][2] * arr[0] + matrix[1][2] * arr[1] + matrix[2][2] * arr[2];
// }

// void threeByThreeTimesThreeByOne(double matrix[3][3], double arr[3], double out[3]) {
// 	out[0] = matrix[0][0] * arr[0] + matrix[0][1] * arr[1] + matrix[0][2] * arr[2];
// 	out[1] = matrix[1][0] * arr[0] + matrix[1][1] * arr[1] + matrix[1][2] * arr[2];
// 	out[2] = matrix[2][0] * arr[0] + matrix[2][1] * arr[1] + matrix[2][2] * arr[2];
// }

// void threeByThreeTimesThreeByThree(double mat1[3][3], double mat2[3][3], double out[3][3]) {
// 	for (int i = 0; i < 3; i++) {
// 		for (int j = 0; j < 3; j++) {
// 			out[i][j] = mat1[i][0] * mat2[0][j] + mat1[i][1] * mat2[1][j] + mat1[i][2] * mat2[2][j];
// 		}
// 	}
// }

// void magnitude(double arr[3], double &out) {
// 	double t1 = pow(arr[0], 2);
// 	double t2 = pow(arr[1], 2);
// 	double t3 = pow(arr[2], 2);
// 	out = sqrt(t1 + t2 + t3);
// }

// void subtractTwoVectors(double vec1[3], double vec2[3], double out[3]) {
// 	out[0] = vec2[0] - vec1[0];
// 	out[1] = vec2[1] - vec1[1];
// 	out[2] = vec2[2] - vec1[2];
// }

// void addTwoVectors(double vec1[3], double vec2[3], double out[3]) {
// 	out[0] = vec2[0] + vec1[0];
// 	out[1] = vec2[1] + vec1[1];
// 	out[2] = vec2[2] + vec1[2];
// }

// void multiplyTwoVectors(double vec1[3], double vec2[3], double out[3]) {
// 	out[0] = vec2[0] * vec1[0];
// 	out[1] = vec2[1] * vec1[1];
// 	out[2] = vec2[2] * vec1[2];
// }

// void crossProductTwoVectors (double vec1[3], double vec2[3], double out[3]) {
// 	out[0] = vec1[1] * vec2[2] - vec1[2] * vec2[1];
// 	out[1] = vec1[2] * vec2[0] - vec1[0] * vec2[2];
// 	out[2] = vec1[0] * vec2[1] - vec1[1] * vec2[0];
// }

// void dotProductTwoVectors (double vec1[3], double vec2[3], double &out) {
// 	out = vec1[0] * vec2[0] + vec1[1] * vec2[1] + vec1[2] * vec2[2];
// }

// void vectorProjection (double uv[3], double vec[3], double out[3]) {
// 	double uvXvu[3][3];
// 	uvXvu[0][0] = uv[0] * uv[0];
// 	uvXvu[0][1] = uv[0] * uv[1];
// 	uvXvu[0][2] = uv[0] * uv[2];
// 	uvXvu[1][0] = uv[1] * uv[0];
// 	uvXvu[1][1] = uv[1] * uv[1];
// 	uvXvu[1][2] = uv[1] * uv[2];
// 	uvXvu[2][0] = uv[2] * uv[0];
// 	uvXvu[2][1] = uv[2] * uv[1];
// 	uvXvu[2][2] = uv[2] * uv[2];
// 	out[0] = uvXvu[0][0] * vec[0] + uvXvu[0][1] * vec[1] + uvXvu[0][2] * vec[2];
// 	out[1] = uvXvu[1][0] * vec[0] + uvXvu[1][1] * vec[1] + uvXvu[1][2] * vec[2];
// 	out[2] = uvXvu[2][0] * vec[0] + uvXvu[2][1] * vec[1] + uvXvu[2][2] * vec[2];
// }

// void multiplyVectorTimesScalar(double scalar, double vec[3], double out[3]) {
// 	out[0] = scalar * vec[0];
// 	out[1] = scalar * vec[1];
// 	out[2] = scalar * vec[2];
// }

// void lookUpTablesFormat () {
// 	// LOOK UP DATA
// 	ifstream inFile("shortRangeInterceptorTables.txt");
// 	// STRING OF FILE LINE
// 	string line;
// 	// TABLE NUMBER
// 	int tableNoTrack = 0;
// 	// ROW NUMBER
// 	int rowNoTrack = 0;
// 	// VECTOR TO STORE TABLE DIMENSIONS
// 	vector<vector<int>> dimensions;
// 	// LOOP
// 	while(getline(inFile, line))
// 	{
// 		// FLAG FOR INDICATION OF LINE CLASSIFICATION >>> 1 = ONE DIMENSIONAL TABLE SIZE; TWO = TWO DIMENSIONAL TABLE SIZE; THREE = TABLE NAME
// 		int flag = 0;
// 		// INITIALIZE NAME OF TABLE
// 		string name;
// 		// INITIALIZE DIMENSION OF SPECIFIC TABLE
// 		vector<int> dimension;
// 		// FIND TABLE NAME
// 		if (line.substr(0, 4) == "NAME"){
// 			// RE INIT ROW NUMBER TRACKER
// 			rowNoTrack = 0;
// 			// STORE NAME OF TABLE
// 			name = line.substr(5, line.size() - 6);
// 			// TRACK TABLE NUMBER
// 			tableNoTrack += 1;
// 			// MARK FLAG FOR LATER USE
// 			flag = 3;
// 		}
// 		// FIND TABLE DIMENSION
// 		else if (line.substr(0, 2) == "NX"){
// 			// MARK FLAG FOR LATER USE
// 			flag = 1;
// 			// STORE "ROWS" DIMENSION
// 			int D1 = stoi(line.substr(4, 3));
// 			// STORE "ROWS" DIMENSIONS IN VECTOR
// 			dimension.push_back(D1);
// 			// INITIALIZE "COLUMNS" DIMENSION
// 			int D2 = 0;
// 			// CHECK FOR A DETERMINED "COLUMNS" DIMENSION
// 			for (int i = 3; i < line.size(); i++) {
// 				// CHECK
// 				if (line.substr(i, 2) == "NX") {
// 					// MARK FLAG FOR LATER USE
// 					flag = 2;
// 					// ADD ONE TO ROWS DIMENSION SINCE THIS IS A TWO DIMENSIONAL TABLE
// 					dimension[0] += 1;
// 					// STORE "COLUMNS" DIMENSION
// 					D2 = stoi(line.substr(i+4, 3)) + 1;
// 					// STORE "COLUMNS" DIMENSION IN VECTOR
// 					dimension.push_back(D2);
// 				}
// 			}
// 			// IF NO DETERMINED SECOND DIMENSION
// 			if (D2 == 0) {
// 				// "COLUMNS" DIMENSION BECOMES TWO
// 				D2 = 2;
// 				// STORE "COLUMNS" DIMENSION IN VECTOR
// 				dimension.push_back(D2);
// 			}
// 		}
// 		// NOTHING FLAGGED, NEXT ITERATION
// 		if (flag == 0){
// 			// ONLY CHECK IF A TABLE HAS BEEN INITIALIZED
// 			if (dimensions.size() > 0){
// 				// COUNT ROW NUMBER
// 				rowNoTrack += 1;
// 				// PARSE LINE THROUGH A STREAM
// 				istringstream parseLine(line);
// 				// INITIALIZE COLUMN COUNTER
// 				int columnCount = 0;
// 				// LOOP THROUGH ONE ROW, ALL COLUMNS
// 				do
// 				{
// 					// ITERATE COLUMN COUNTER
// 					columnCount += 1;
// 					// INITIALIZE DATA POINT
// 					string dataPoint;
// 					// GRAB DATA POINT FROM PARSES
// 					parseLine >> dataPoint;
// 					// CHECK TO MAKE SURE IT IS NOT WHITESPACE
// 					if (dataPoint.find_first_not_of(' ') != std::string::npos){
// 						// CONVERT STRING TO DOUBLE
// 						double dataPointDouble = stod(dataPoint);
// 						/////////// FOR THIS SPECIFIC SET OF DATA, CHECK FOR 90. THERE ARE 14 ROWS AND 15 COLUMNS FOR THE TWO DIMENSIONAL TABLES WHICH MEANS THIS IS A SPECIFIC PIECE OF CODE. WOULD HAVE TO BE ALTERED FOR DIFFERING DATA SETS.
// 						if (dataPointDouble == 90) {
// 							// PLACE IT AT THE FAR RIGHT CORNER
// 							tables[tableNoTrack - 1][0].back() = dataPointDouble;
// 						}
// 						// IF THIS THE FIRST LOOP, THIS IS THE COLUMN IN THE DATA SET THAT DISPLAYS THE "ROWS" VALUES
// 						else if (columnCount == 1) {
// 							// FOR TWO DIMENSIONAL TABLE
// 							if (dimensions[tableNoTrack -1][1] != 2){
// 								// PLACE DATA POINT IN ITS PLACE
// 								tables[tableNoTrack - 1][rowNoTrack][0] = dataPointDouble;
// 							}
// 							// FOR ONE DIMENSIONAL TABLE
// 							else {
// 								// PLACE DATA POINT IN ITS PLACE
// 								tables[tableNoTrack - 1][rowNoTrack - 1][0] = dataPointDouble;
// 							}
// 						}
// 						// IF THIS THE SECOND LOOP, THIS IS THE COLUMN IN THE DATA SET THAT DISPLAYS THE "COLUMNS" VALUES, ONLY FOR TWO DIMENSIONAL TABLES
// 						else if (columnCount == 2 and dimensions[tableNoTrack -1][1] != 2) {
// 							// PLACE DATA POINT IN ITS PLACE
// 							tables[tableNoTrack - 1][0][rowNoTrack] = dataPointDouble;
// 						}
// 						// ELSE FOR ACTUAL DATA POINTS
// 						else {
// 							// FOR TWO DIMENSIONAL TABLES
// 							if (dimensions[tableNoTrack -1][1] != 2) {
// 								// PLACE DATA POINT IN ITS PLACE
// 								tables[tableNoTrack - 1][rowNoTrack][columnCount - 2] = dataPointDouble;
// 							}
// 							// FOR ONE DIMENSIONAL TABLES
// 							else {
// 								// PLACE DATA POINT IN ITS PLACE
// 								tables[tableNoTrack - 1][rowNoTrack - 1][columnCount - 1] = dataPointDouble;
// 							}
// 						}
// 					}
// 				} while (parseLine);
// 			}
// 		}
// 		// CREATE A TABLE OF CORRECT SIZE AND STORE IT
// 		else if (flag == 1 or flag == 2){
// 			// STORE VECTOR OF DIMENSIONS
// 			dimensions.push_back(dimension);
// 			// SEPERATE ROW DIMENSION
// 			int rows = dimension[0];
// 			// SEPERATE COLUMN DIMENSION
// 			int columns = dimension[1];
// 			// CREATE TABLE
// 			vector<vector<double>> newTable(rows, vector<double>(columns));
// 			// TOP LEFT CORNER OF TABLE UNUSED
// 			newTable[0][0] = 0.0;
// 			// STORE NEW TABLE IN VECTOR
// 			tables.push_back(newTable);
// 		}
// 		// STORE NAME OF TABLE
// 		else if (flag == 3){
// 			// MAP TABLE NAME INDEX PAIR
// 			tableNameIndexPairs.emplace(name, tableNoTrack - 1);
// 		}
// 	}
// }

// double linearInterpolationWithBoundedEnds(string tableName, double tableInput) {
// 	int tableIndex = tableNameIndexPairs[tableName];
// 	int lowIndex = -100000;
// 	int highIndex = 100000;
// 	double interpolatedValue;
// 	for (int i = 0; i < tables[tableIndex].size(); i++) {
// 		double refValue = tables[tableIndex][i][0];
// 		if (refValue > tableInput) {
// 			if (highIndex == 100000) {
// 				highIndex = i;
// 			}
// 			else if (refValue < tables[tableIndex][highIndex][0]) {
// 				highIndex = i;
// 			}
// 		}
// 		else if (refValue < tableInput) {
// 			if (lowIndex == -100000) {
// 				lowIndex = i;
// 			}
// 			else if (refValue > tables[tableIndex][lowIndex][0]) {
// 				lowIndex = i;
// 			}
// 		}
// 	}
// 	if (lowIndex == -100000) {
// 		lowIndex = 0;
// 		interpolatedValue = tables[tableIndex][lowIndex][1];
// 	}
// 	else if (highIndex == 100000) {
// 		highIndex = tables[tableIndex].size() - 1;
// 		interpolatedValue = tables[tableIndex][highIndex][1];
// 	}
// 	else {
// 		interpolatedValue = tables[tableIndex][lowIndex][1] + ((tableInput - tables[tableIndex][lowIndex][0]) * ((tables[tableIndex][highIndex][1] - tables[tableIndex][lowIndex][1]) / (tables[tableIndex][highIndex][0] - tables[tableIndex][lowIndex][0])));
// 	}
// 	return interpolatedValue;
// }

// double biLinearInterpolationWithBoundedBorders(string tableName, double tableRowInput, double tableColumnInput) {
// 	int tableIndex = tableNameIndexPairs[tableName];
// 	int lowRowIndex = -100000;
// 	int highRowIndex = 100000;
// 	int lowColIndex = -100000;
// 	int highColIndex = 100000;
// 	int rows = tables[tableIndex].size() - 1;
// 	int cols = tables[tableIndex][0].size() - 1;
// 	double interpolatedValue;
// 	for (int i = 1; i <= rows; i++) {
// 		double refValue = tables[tableIndex][i][0];
// 		if (refValue >= tableRowInput) {
// 			if (highRowIndex == 100000) {
// 				highRowIndex = i;
// 			}
// 			else if (refValue < tables[tableIndex][highRowIndex][0]) {
// 				highRowIndex = i;
// 			}
// 		}
// 		else if (refValue <= tableRowInput) {
// 			if (lowRowIndex == -100000) {
// 				lowRowIndex = i;
// 			}
// 			else if (refValue > tables[tableIndex][lowRowIndex][0]) {
// 				lowRowIndex = i;
// 			}
// 		}
// 	}
// 	if (lowRowIndex == -100000) {
// 		lowRowIndex = 1;
// 	}
// 	if (highRowIndex == 100000) {
// 		highRowIndex = rows;
// 	}
// 	for (int i = 1; i <= cols; i++) {
// 		double refValue = tables[tableIndex][0][i];
// 		if (refValue >= tableColumnInput) {
// 			if (highColIndex == 100000) {
// 				highColIndex = i;
// 			}
// 			else if (refValue < tables[tableIndex][0][highColIndex]) {
// 				highColIndex = i;
// 			}
// 		}
// 		else if (refValue <= tableColumnInput) {
// 			if (lowColIndex == -100000) {
// 				lowColIndex = i;
// 			}
// 			else if (refValue > tables[tableIndex][0][lowColIndex]) {
// 				lowColIndex = i;
// 			}
// 		}
// 	}
// 	if (lowColIndex == -100000) {
// 		lowColIndex = 1;
// 	}
// 	if (highColIndex == 100000) {
// 		highColIndex = cols;
// 	}

// 	if (lowRowIndex == highRowIndex and lowColIndex != highColIndex) {
// 		double x = tableColumnInput;
// 		double x1 = tables[tableIndex][0][lowColIndex];
// 		double x2 = tables[tableIndex][0][highColIndex];
// 		double y1 = tables[tableIndex][highRowIndex][lowColIndex];
// 		double y2 = tables[tableIndex][highRowIndex][highColIndex];
// 		interpolatedValue = y1 + (x - x1) * ((y2 - y1) / (x2 - x1));
// 	}
// 	else if (lowRowIndex != highRowIndex and lowColIndex == highColIndex) {
// 		double x = tableRowInput;
// 		double x1 = tables[tableIndex][lowRowIndex][0];
// 		double x2 = tables[tableIndex][highRowIndex][0];
// 		double y1 = tables[tableIndex][lowRowIndex][highColIndex];
// 		double y2 = tables[tableIndex][highRowIndex][highColIndex];
// 		interpolatedValue = y1 + (x - x1) * ((y2 - y1) / (x2 - x1));
// 	}
// 	else if (lowRowIndex == highRowIndex and lowColIndex == highColIndex) {
// 		interpolatedValue = tables[tableIndex][highRowIndex][highColIndex];
// 	}
// 	else {
// 		double x1 = tables[tableIndex][lowRowIndex][0];
// 		double x2 = tables[tableIndex][highRowIndex][0];
// 		double y1 = tables[tableIndex][0][lowColIndex];
// 		double y2 = tables[tableIndex][0][highColIndex];
// 		double corner11 = tables[tableIndex][lowRowIndex][lowColIndex];
// 		double corner12 = tables[tableIndex][lowRowIndex][highColIndex];
// 		double corner21 = tables[tableIndex][highRowIndex][lowColIndex];
// 		double corner22 = tables[tableIndex][highRowIndex][highColIndex];
// 		double t1 = corner11 * (x2 - tableRowInput) * (y2 - tableColumnInput);
// 		double t2 = corner21 * (tableRowInput - x1) * (y2 - tableColumnInput);
// 		double t3 = corner12 * (x2 - tableRowInput) * (tableColumnInput - y1);
// 		double t4 = corner22 * (tableRowInput - x1) * (tableColumnInput - y1);
// 		interpolatedValue = (t1 + t2 + t3 + t4) / ((x2 - x1) * (y2 - y1));
// 	}
// 	return interpolatedValue;
// }