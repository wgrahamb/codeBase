		double lineOfAttack[3];
		lineOfAttack[0] = forwardLeftUpMissileToInterceptPositionUnitVector[0];
		if (forwardLeftUpMissileToInterceptPositionUnitVector[1] < 0.0)
		{
			lineOfAttack[1] = -10 * degToRad;
		}
		else
		{
			lineOfAttack[1] = 10 * degToRad;
		}
		lineOfAttack[2] = -10 * degToRad;
		double TEMP1[3];
		TEMP1[0] = 4.0 * forwardLeftUpMissileToInterceptPositionUnitVector[0] - 1.5 * lineOfAttack[0];
		TEMP1[1] = 4.0 * forwardLeftUpMissileToInterceptPositionUnitVector[1] - 1.5 * lineOfAttack[1];
		TEMP1[2] = 4.0 * forwardLeftUpMissileToInterceptPositionUnitVector[2] - 1.5 * lineOfAttack[2];
		double closingSpeedUnit[3];
		unitVec(missile.FLUVelocity, closingSpeedUnit);
		double TEMP2[3];
		crossProductTwoVectors(TEMP1, closingSpeedUnit, TEMP2);
		double TEMP3[3];
		crossProductTwoVectors(closingSpeedUnit, TEMP2, TEMP3);
		double closingSpeed;
		magnitude(missile.FLUVelocity, closingSpeed);
		double TEMP4 = closingSpeed * closingSpeed / forwardLeftUpMissileToInterceptPositionMagnitude;
		double COMMAND[3];
		multiplyVectorTimesScalar(TEMP4, TEMP3, COMMAND);
		missile.guidanceNormalCommand = COMMAND[2];
		missile.guidanceSideCommand = COMMAND[1];