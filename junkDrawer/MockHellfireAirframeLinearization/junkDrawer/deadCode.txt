# ### FUNCTION NEEDED HERE ###
# if MACHSPEED > 1:
# 	BETA = np.sqrt(MACHSPEED ** 2 - 1) # Non dimensional.
# else:
# 	BETA = MACHSPEED # Non dimensional.

# # AERODYNAMICS.
# CNTRIM = MASS * FIRST_ACCEL_COMMAND_IN_GS / (DYNAMIC_PRESSURE * REFERENCE_AREA)
# Y1 = 2 + 8 * WING_AREA / (BETA * REFERENCE_AREA) + 8 * TAIL_AREA / (BETA * REFERENCE_AREA)
# Y2 = 1.5 * PLANFORM_AREA / REFERENCE_AREA
# Y3 = 8 * TAIL_AREA / (BETA * REFERENCE_AREA)
# Y4 = 2 * TEMP4 + 8 * WING_AREA * TEMP1 / (BETA * REFERENCE_AREA) + 8 * TAIL_AREA * TEMP2 / (BETA * REFERENCE_AREA)
# Y5 = 1.5 * PLANFORM_AREA * TEMP3 / REFERENCE_AREA
# Y6 = 8 * TAIL_AREA * TEMP2 / (BETA * REFERENCE_AREA)
# P2 = Y2 - (Y3 * Y5) / Y6
# P3 = Y1 - (Y3 * Y4) / Y6
# ALPHA_TRIM = (-1 * P3 + np.sqrt(P3 * P3 + 4 * P2 * CNTRIM)) / (2 * P2)
# DELTA_TRIM = (-1 * Y4 * ALPHA_TRIM - Y5 * ALPHA_TRIM * ALPHA_TRIM) / Y6
# CNA = 2 + 1.5 * PLANFORM_AREA * ALPHA_TRIM / REFERENCE_AREA + 8 * WING_AREA / (BETA * REFERENCE_AREA) + 8 * TAIL_AREA / (BETA * REFERENCE_AREA)
# CND = 8 * TAIL_AREA / (BETA * REFERENCE_AREA)
# ZA = -1 * STANDARD_GRAVITY * DYNAMIC_PRESSURE * REFERENCE_AREA * CNA / (MASS * AIRSPEED)
# ZD = -1 * STANDARD_GRAVITY * DYNAMIC_PRESSURE * REFERENCE_AREA * CND / (MASS * AIRSPEED)
# CMAP = 2 * TEMP4 + 1.5 * PLANFORM_AREA * ALPHA_TRIM * TEMP3 / REFERENCE_AREA + 8 * WING_AREA * TEMP1 / (BETA * REFERENCE_AREA)
# CMA = CMAP + 8 * TAIL_AREA * TEMP2 / (BETA * REFERENCE_AREA)
# CMD = 8 * TAIL_AREA * TEMP2 / (BETA * REFERENCE_AREA)
# MA = DYNAMIC_PRESSURE * REFERENCE_AREA * REFERENCE_DIAMETER * CMA / TRANSVERSE_MOMENT_OF_INERTIA
# MD = DYNAMIC_PRESSURE * REFERENCE_AREA * REFERENCE_DIAMETER * CMD / TRANSVERSE_MOMENT_OF_INERTIA

# # CONTROL.
# OMEGA_Z = np.sqrt((MA * ZD - MD * ZA) / ZD)
# OMEGA_AF = np.sqrt(-1 * MA)
# ZETA_AF = ZA * OMEGA_AF / (2 * MA)
# KR = 0.1
# K1 = -1 * AIRSPEED * ((MA * ZD - ZA * MD) / (1845 * MA))
# TA = MD / (MA * ZD - MD * ZA)
# K3 = 1845 * K1 / AIRSPEED
# KDC = (1 - KR * K3) / (K1 * KR)
# ### END FUNCTION NEEDED HERE ###

# Gonna leave uncorrected and see what happens.
# REFERENCE_LENGTH = 1.6 # Meters.
REFERENCE_LENGTH = 1.85026 # Meters.

# Gonna leave uncorrected and see what happens.
# CENTER_OF_DEFLECTION_FROM_NOSE = 1.8059 - NOSE_LENGTH # Meters (correction here due to oversight in drawing).
CENTER_OF_DEFLECTION_FROM_NOSE = 1.8059 # Meters.

E += EDOT * TIME_STEP
EDOT += EDOTDOT * TIME_STEP

THETA_DOT = K3 * (E + TA * EDOT)
NORMAL_SPECIFIC_FORCE = K1 * (E - (EDOTDOT / (OMEGA_Z ** 2)))

# EQUATIONS OF MOTION.
ACCELERATION = npa([0.0, NORMAL_SPECIFIC_FORCE * GRAVITY])

DELTA_POSITION = VELOCITY * TIME_STEP
POSITION += DELTA_POSITION

DELTA_VELOCITY = ACCELERATION * TIME_STEP
VELOCITY += DELTA_VELOCITY

THETA += THETA_DOT * TIME_STEP
ALPHA_OLD = ALPHA
ALPHA = np.arctan2(VELOCITY[1], VELOCITY[0])
ALPHA_DOT = (ALPHA_OLD - ALPHA) * (1.0 / TIME_STEP)

# ITERATE TIME OF FLIGHT
TOF += TIME_STEP

MissileMotionObject.update(
	OMEGA_Z = OMEGA_Z,
	OMEGA_AF=OMEGA_AF,
	ZETA_AF=ZETA_AF,
	KR=KR,
	K1=K1,
	TA=TA,
	K3=K3,
	DEFLECTION=DEFLECTION,
	GRAVITY=GRAVITY,
	MAX_TIME=TOF + TIME_STEP
)
T_E = MissileMotionObject.E
T_EDOT = MissileMotionObject.EDOT
T_ACCELERATION = MissileMotionObject.ACCELERATION # Meters per second squared.
T_POSITION = MissileMotionObject.POSITION # Meters.
T_VELOCITY = MissileMotionObject.VELOCITY # Meters per second.
T_THETA = MissileMotionObject.THETA # Radians.
T_ALPHA = MissileMotionObject.ALPHA # Radians.
T_ALPHA_DOT = MissileMotionObject.ALPHA_DOT # Radians per second.
T_THETA_DOT = MissileMotionObject.THETA_DOT # Radians per second.
T_NORMAL_SPECIFIC_FORCE = MissileMotionObject.NORMAL_SPECIFIC_FORCE # Meters per second squared.
T_TOF = MissileMotionObject.TOF # Seconds.

print("E", T_E, E)
print("EDOT", T_EDOT, EDOT)
print("ACCEL", T_ACCELERATION, ACCELERATION)
print("POS", T_POSITION, POSITION)
print("VEL", T_VELOCITY, VELOCITY)
print("THETA", T_THETA, THETA)
print("ALPHA", T_ALPHA, ALPHA)
print("ALPHA_DOT", T_ALPHA_DOT, ALPHA_DOT)
print("THETA_DOT", T_THETA_DOT, THETA_DOT)
print("NORMAL SF", T_NORMAL_SPECIFIC_FORCE, NORMAL_SPECIFIC_FORCE)
print("TOF", T_TOF, TOF)
print("\n")

DEFL_LIMIT = 25 # Degrees.
DEFL_RATE_LIMIT = 50 # Degrees per second.
WNACT = 10 * RAD_TO_DEG # Degrees per second.
ZETACT = 0.7 # Non dimensional.
DEFLECTION = 0.0 # Degrees.
DEFLECTION_DOT_DER = 0.0 # Degrees per second.
DEFLECTION_DOT = 0.0 # Degrees per second.
DEFLECTION_DOT_DOT = 0.0 #  # Degrees per second.squared.













